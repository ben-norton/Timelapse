using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using Timelapse.Controls;
using Timelapse.Database;
using Timelapse.Dialog;
using Timelapse.Util;
using MessageBox = Timelapse.Dialog.MessageBox;

namespace Timelapse
{
    /// <summary>
    /// Interaction logic for DialogDateTimeLinearCorrection.xaml
    /// This dialog lets the user specify a corrected date and time of a file. All other dates and times are then corrected by the same amount.
    /// This is useful if (say) the camera was not initialized to the correct date and time.
    /// </summary>
    public partial class DateTimeLinearCorrection : Window
    {
        private readonly FileDatabase fileDatabase;

        // Tokens to let us cancel the Reread Task
        private readonly CancellationTokenSource TokenSource;
        private CancellationToken Token;
        private bool IsDatabaseAltered;

        private DateTimeOffset latestImageDateTime;
        private DateTimeOffset earliestImageDateTime;

        // Create the interface
        public DateTimeLinearCorrection(Window owner, FileDatabase fileDatabase)
        {
            // Check the arguments for null 
            if (fileDatabase == null)
            {
                // this should not happen
                TraceDebug.PrintStackTrace(1);
                throw new ArgumentNullException(nameof(fileDatabase));
            }

            this.InitializeComponent();
            this.Owner = owner;
            this.fileDatabase = fileDatabase;

            // Initialize the cancellation token
            this.TokenSource = new CancellationTokenSource();
            this.Token = this.TokenSource.Token;

            // Tracks whether any changes to the database was made
            this.IsDatabaseAltered = false;
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            Dialogs.TryPositionAndFitDialogIntoWindow(this);

            // Set up the initial UI and values
            this.latestImageDateTime = DateTimeOffset.MinValue;
            this.earliestImageDateTime = DateTimeOffset.MaxValue;

            // Search the images for the two images with the earliest and latest data/time date 
            ImageRow latestImageRow = null;
            ImageRow earliestImageRow = null;
            foreach (ImageRow image in this.fileDatabase.FileTable)
            {
                DateTimeOffset currentImageDateTime = image.DateTimeIncorporatingOffset;

                // If the current image's date is later, then it is a candidate latest image  
                if (currentImageDateTime >= this.latestImageDateTime)
                {
                    latestImageRow = image;
                    this.latestImageDateTime = currentImageDateTime;
                }

                // If the current image's date is earlier, then it is a candidate earliest image  
                if (currentImageDateTime <= this.earliestImageDateTime)
                {
                    earliestImageRow = image;
                    this.earliestImageDateTime = currentImageDateTime;
                }
            }

            // At this point, we should have succeeded getting the oldest and newest data/time

            // Configure the earliest date (in datetime picker) and its image
            this.earliestImageName.Content = earliestImageRow.File;
            this.earliestImageDate.Content = DateTimeHandler.ToDisplayDateTimeString(this.earliestImageDateTime);
            this.imageEarliest.Source = earliestImageRow.LoadBitmap(this.fileDatabase.FolderPath, out bool isCorruptOrMissing);

            // Configure the latest date (in datetime picker) and its image
            this.latestImageName.Content = latestImageRow.File;
            DataEntryHandler.Configure(this.dateTimePickerLatestDateTime, this.latestImageDateTime.DateTime);
            this.dateTimePickerLatestDateTime.ValueChanged += this.DateTimePicker_ValueChanged;
            this.imageLatest.Source = latestImageRow.LoadBitmap(this.fileDatabase.FolderPath, out isCorruptOrMissing);
        }

        // Label and size the datagrid column headers
        private void DatagridFeedback_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "File name (only for files whose date differs)";
            this.FeedbackGrid.Columns[0].Width = new DataGridLength(1, DataGridLengthUnitType.Auto);
            this.FeedbackGrid.Columns[1].Header = "Old date  \x2192  New Date \x2192 Delta";
            this.FeedbackGrid.Columns[1].Width = new DataGridLength(2, DataGridLengthUnitType.Star);
        }

        #region ProgressBar helper
        // Convenience routing to show progress information in the progress bar
        // and to enable or disable its cancel button
        private void UpdateProgressBar(int percent, string message, bool cancelEnabled)
        {
            ProgressBar bar = Utilities.GetVisualChild<ProgressBar>(this.BusyIndicator);
            TextBlock textmessage = Utilities.GetVisualChild<TextBlock>(this.BusyIndicator);
            Button cancelButton = Utilities.GetVisualChild<Button>(this.BusyIndicator);
            if (bar != null)
            {
                bar.Value = percent;
            }
            if (textmessage != null)
            {
                textmessage.Text = message;
            }
            if (cancelButton != null)
            {
                cancelButton.IsEnabled = cancelEnabled;
                cancelButton.Content = cancelButton.IsEnabled ? "Cancel" : "Writing data...";
            }
        }
        #endregion

        private async Task<ObservableCollection<DateTimeFeedbackTuple>> TaskLinearCorrectionAsync(TimeSpan newestImageAdjustment, TimeSpan intervalFromOldestToNewestImage)
        {
            // Set up a progress handler that will update the progress bar
            Progress<ProgressBarArguments> progressHandler = new Progress<ProgressBarArguments>(value =>
            {
                // Update the progress bar
                this.UpdateProgressBar(value.PercentDone, value.Message, value.CancelEnabled);
            });
            IProgress<ProgressBarArguments> progress = progressHandler as IProgress<ProgressBarArguments>;

            // Reread the Date/Times from each file 
            return await Task.Run(() =>
            {
                // Note. 
                // Pass 1 is just to generates feedback information of what would happen (put in feedbackRows - the interpolation done there is only to get that information 
                // Pass 2 actually does the interpolation and updates the database as needed.
                // Its done separately as we can't access that feedback information from the database call.

                ObservableCollection<DateTimeFeedbackTuple> feedbackRows = new ObservableCollection<DateTimeFeedbackTuple>();

                // Pass 1. Examine each file, and generate a feedback line in feedbackRows if its interpolation would lead to a change
                progress.Report(new ProgressBarArguments(0, "Pass 1: Examining image and video dates..."));
                Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allow the UI to update.

                int count = this.fileDatabase.FileTable.RowCount;

                // this.GetFeedbackForFilesWithInterpolatedDates(progress, count, newestImageAdjustment, intervalFromOldestToNewestImage, feedbackRows);

                // We are done if the operation has been cancelled
                if (CheckIfAllDone(feedbackRows))
                {
                    return feedbackRows;
                }

                // Pass 2. Actually interpolate each date and update the database if the interpolation would lead to a change
                string message = String.Format("Pass 2: Updating {0} files. Please wait...", count);
                progress.Report(new ProgressBarArguments(0, message, false));
                Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allow the UI to update.

                this.DatabaseUpdateFileDates(progress, intervalFromOldestToNewestImage, newestImageAdjustment, feedbackRows);

                this.IsDatabaseAltered = true;
                return feedbackRows;

            }, this.Token).ConfigureAwait(continueOnCapturedContext: true); // Set to true as we need to continue in the UI context
        }

        private void GetFeedbackForFilesWithInterpolatedDates(IProgress<ProgressBarArguments> progress, int count, TimeSpan newestImageAdjustment, TimeSpan intervalFromOldestToNewestImage, ObservableCollection<DateTimeFeedbackTuple> feedbackRows)
        {
            int fileIndex = 1;
            foreach (ImageRow image in this.fileDatabase.FileTable)
            {
                if (Token.IsCancellationRequested)
                {
                    // A cancel was requested. Clear all pending changes and abort
                    feedbackRows.Clear();
                    break;
                }

                string oldDT = image.Date + " " + image.Time;
                string newDT = String.Empty;
                string difference = string.Empty;
                double imagePositionInInterval;

                DateTimeOffset imageDateTime;
                TimeSpan oneSecond = TimeSpan.FromSeconds(1);

                imageDateTime = image.DateTimeIncorporatingOffset;
                // adjust the date / time
                if (intervalFromOldestToNewestImage == TimeSpan.Zero)
                {
                    imagePositionInInterval = 1;
                }
                else
                {
                    imagePositionInInterval = (imageDateTime - this.earliestImageDateTime).Ticks / (double)intervalFromOldestToNewestImage.Ticks;
                }
                TimeSpan adjustment = TimeSpan.FromTicks((long)(imagePositionInInterval * newestImageAdjustment.Ticks));

                // Pretty print the adjustment time
                if (adjustment.Duration() >= oneSecond)
                {
                    difference = PrettyPrintTimeAdjustment(adjustment);

                    // Get the new date/time
                    newDT = DateTimeHandler.ToDisplayDateTimeString(imageDateTime + adjustment);

                    progress.Report(new ProgressBarArguments(Convert.ToInt32(fileIndex / Convert.ToDouble(count) * 100.0), String.Format("Pass 1: Calculating new date/times for {0} / {1} files", fileIndex, count)));
                    // Put in a delay every now and then, as otherwise the UI won't update.
                    if (fileIndex % Constant.ThrottleValues.SleepForImageRenderInterval == 0)
                    {
                        Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);
                    }

                    fileIndex++;
                    feedbackRows.Add(new DateTimeFeedbackTuple(image.File, oldDT + " \x2192 " + newDT + " \x2192 " + difference));
                }
            }
        }

        private static string PrettyPrintTimeAdjustment(TimeSpan adjustment)
        {
            string sign = (adjustment < TimeSpan.Zero) ? "-" : "+";

            // Pretty print the adjustment time, depending upon how many day(s) were included 
            string format;
            if (adjustment.Days == 0)
            {
                format = "{0:s}{1:D2}:{2:D2}:{3:D2}"; // Don't show the days field
            }
            else if (adjustment.Duration().Days == 1)
            {
                format = "{0:s}{1:D2}:{2:D2}:{3:D2} {0:s} {4:D} day";
            }
            else
            {
                format = "{0:s}{1:D2}:{2:D2}:{3:D2} {0:s} {4:D} days";
            }
            return string.Format(format, sign, adjustment.Duration().Hours, adjustment.Duration().Minutes, adjustment.Duration().Seconds, adjustment.Duration().Days);
        }

        // We are done if the operation has been cancelled, or there are no files with changed dates.
        private bool CheckIfAllDone(ObservableCollection<DateTimeFeedbackTuple> feedbackRows)
        {
            string message;
            // Abort (with feedback) the operation was cancelled
            if (Token.IsCancellationRequested == true)
            {
                feedbackRows.Clear();
                message = "No changes were made";
                feedbackRows.Add(new DateTimeFeedbackTuple("Cancelled", message));
                return true;
            }
            return false;
        }

        // Update dates in the database for the given image rows 
        private static DateTime lastRefreshDateTime = DateTime.Now;
        private void DatabaseUpdateFileDates(IProgress<ProgressBarArguments> progress, TimeSpan intervalFromOldestToNewestImage, TimeSpan newestImageAdjustment, ObservableCollection<DateTimeFeedbackTuple> feedbackRows)
        {
            if (intervalFromOldestToNewestImage == TimeSpan.Zero)
            {
                this.fileDatabase.AdjustFileTimes(newestImageAdjustment);
            }
            else
            {
                this.fileDatabase.AdjustFileTimes(
                   (string fileName, int fileIndex, int count, DateTimeOffset imageDateTime) =>
                   {
                       double imagePositionInInterval = (imageDateTime - this.earliestImageDateTime).Ticks / (double)intervalFromOldestToNewestImage.Ticks;
                       Debug.Assert((-0.0000001 < imagePositionInInterval) && (imagePositionInInterval < 1.0000001), String.Format("Interval position {0} is not between 0.0 and 1.0.", imagePositionInInterval));
                       TimeSpan adjustment = TimeSpan.FromTicks((long)(imagePositionInInterval * newestImageAdjustment.Ticks)); // Used to have a  .5 increment, I think to force rounding upwards                                                                                                        // TimeSpan.Duration means we do these checks on the absolute value (positive) of the Timespan, as slow clocks will have negative adjustments.
                       Debug.Assert((TimeSpan.Zero <= adjustment.Duration()) && (adjustment.Duration() <= newestImageAdjustment.Duration()), String.Format("Expected adjustment {0} to be within [{1} {2}].", adjustment, TimeSpan.Zero, newestImageAdjustment));

                       if (adjustment.Duration() >= TimeSpan.FromSeconds(1))
                       {
                           // We only add to the feedback row if the change duration is > 1 second, as otherwise we don't change it.
                           string oldDT = DateTimeHandler.ToDisplayDateTimeString(imageDateTime);
                           string newDT = DateTimeHandler.ToDisplayDateTimeString(imageDateTime + adjustment);
                           feedbackRows.Add(new DateTimeFeedbackTuple(fileName, oldDT + " \x2192 " + newDT + " \x2192 " + PrettyPrintTimeAdjustment(adjustment)));
                       }

                       // Update the progress bar every time interval to indicate what file we are working on
                       TimeSpan intervalFromLastRefresh = DateTime.Now - lastRefreshDateTime;
                       if (intervalFromLastRefresh > Constant.ThrottleValues.ProgressBarRefreshInterval)
                       {
                           int percentDone = Convert.ToInt32(fileIndex / Convert.ToDouble(count) * 100.0);
                           progress.Report(new ProgressBarArguments(percentDone, String.Format("Pass 1: Calculating new date/times for {0} / {1} files", fileIndex, count)));
                           Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                           lastRefreshDateTime = DateTime.Now;
                       }
                       if (fileIndex >= count)
                       {
                           // After all files are processed, the next step would be updating the database.
                           // This really should be somehow signalled from the invoking method (ideally ExecuteNonQueryWrappedInBeginEnd every update interval), but this is a reasonable workaround.
                           progress.Report(new ProgressBarArguments(100, String.Format("Pass 2: Updating {0} files. Please wait...", count)));
                           Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                       }
                       return imageDateTime + adjustment; // Returns the new time
                   },
                   0,
                   this.fileDatabase.CurrentlySelectedFileCount - 1);
            }
        }

        // 1st click of Ok: Show a preview of the changes.
        // 2nd click of OK: Update the database if the OK button is clicked
        private async void Start_Click(object sender, RoutedEventArgs e)
        {
            // Configure the UI's initial state
            this.CancelButton.IsEnabled = false;
            this.CancelButton.Visibility = Visibility.Hidden;
            this.StartDoneButton.Content = "_Done";
            this.StartDoneButton.Click -= this.Start_Click;
            this.StartDoneButton.Click += this.DoneButton_Click;
            this.StartDoneButton.IsEnabled = false;
            this.BusyIndicator.IsBusy = true;

            // A few checks just to make sure we actually have something to do...
            if (this.dateTimePickerLatestDateTime.Value.HasValue == false)
            {
                // We don't have a valid date, so nothing really to do.
                this.DialogResult = false;
                return;
            }

            TimeSpan newestImageAdjustment = this.dateTimePickerLatestDateTime.Value.Value - this.latestImageDateTime;
            TimeSpan intervalFromOldestToNewestImage = this.latestImageDateTime - this.earliestImageDateTime;
            if (newestImageAdjustment == TimeSpan.Zero)
            {
                // nothing to do
                this.DialogResult = false;
                return;
            }

            ObservableCollection<DateTimeFeedbackTuple> feedbackRows = await this.TaskLinearCorrectionAsync(newestImageAdjustment, intervalFromOldestToNewestImage).ConfigureAwait(true);

            // Hide the busy indicator and update the UI, e.g., to show which files have changed dates
            this.BusyIndicator.IsBusy = false;
            this.PrimaryPanel.Visibility = Visibility.Collapsed;
            this.FeedbackPanel.Visibility = Visibility.Visible;
            this.FeedbackGrid.ItemsSource = feedbackRows;
            this.StartDoneButton.IsEnabled = true;
        }

        #region DateTimePicker callbacks
        private void DateTimePicker_ValueChanged(object sender, RoutedPropertyChangedEventArgs<object> e)
        {
            // Because of the bug in the DateTimePicker, we have to get the changed value from the string
            // as DateTimePicker.Value.Value can have the old date rather than the new one.
            if (DateTimeHandler.TryParseDisplayDateTimeString(this.dateTimePickerLatestDateTime.Text, out DateTime newDateTime) == false)
            {
                // If we can't parse the date,  do nothing.
                // System.Diagnostics.Debug.Print("DateTimeLinearCorrection|ValueChanged: Could not parse the date:" + this.dateTimePickerLatestDateTime.Text);
                return;
            }

            // Don't let the date picker go below the oldest time. If it does, don't change the date and play a beep.
            if (this.dateTimePickerLatestDateTime.Value.Value <= this.earliestImageDateTime)
            {
                MessageBox messageBox = new MessageBox("Your new time has to be later than the earliest time", this);
                messageBox.Message.Icon = MessageBoxImage.Exclamation;
                messageBox.Message.Problem = "Your new time has to be later than the earliest time   ";
                messageBox.Message.Reason = "Even the slowest clock gains some time.";
                messageBox.Message.Solution = "The date/time was unchanged from where you last left it.";
                messageBox.Message.Hint = "The image on the left shows the earliest time recorded for images in this filtered view  shown over the left image";
                messageBox.ShowDialog();
            }

            // Enable the Ok button only if the latest time has actually changed from its original version
            TimeSpan newestImageAdjustment = newDateTime - this.latestImageDateTime;
            this.StartDoneButton.IsEnabled = (newestImageAdjustment == TimeSpan.Zero) ? false : true;
        }

        // Mitigates a bug where ValueChanged is not triggered when the date/time is changed
        private void DateTimePickerLatestDateTime_MouseLeave(object sender, System.Windows.Input.MouseEventArgs e)
        {
            this.DateTimePicker_ValueChanged(null, null);
        }
        #endregion

        #region Other Button callbacks
        private void DoneButton_Click(object sender, RoutedEventArgs e)
        {
            TokenSource.Dispose();
            // We return false if the database was not altered, i.e., if this was all a no-op
            this.DialogResult = this.IsDatabaseAltered;
        }

        // Cancel - do nothing
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }

        private void CancelAsyncOperationButton_Click(object sender, RoutedEventArgs e)
        {
            // Set this so that it will be caught in the above await task
            this.TokenSource.Cancel();
        }
        #endregion
    }
}
