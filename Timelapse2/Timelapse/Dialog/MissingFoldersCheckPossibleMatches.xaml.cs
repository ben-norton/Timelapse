using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Windows;
using System.Windows.Controls;

namespace Timelapse.Dialog
{
    /// <summary>
    /// This dialog is one of several that deals with missing folders, i.e. folders that are not found at their relative paths.
    /// It is given a dictionary of old vs. new folder names, and based on that it displays a table of rows, each showing 
    /// - a folder's name, 
    /// - a relative path to an expected old location of that folder,
    /// - a relative path to a possible new location of that folder
    /// The user can then specify whether 
    /// - return true: the new locations are correct, ()
    /// - return null: they would prefer to update the locations manually (e.g., if they aren't correct) 
    /// - return false: cancel all attempts to find the locaton of missing folders.
    /// </summary>
    public partial class MissingFoldersCheckPossibleMatches : Window
    {
        private readonly string RootPath;
        public bool IsCancelled { get; set; }
        public MissingFoldersCheckPossibleMatches(string rootPath, Dictionary<string,string> possibleMatchesOfOldToNewFolders)
        {
            InitializeComponent();
            this.RootPath = rootPath;
            if (possibleMatchesOfOldToNewFolders == null)
            {
                this.DialogResult = false;
                this.IsCancelled = true;
                return;
            }
            ObservableCollection<Tuple<string,string,string>> missingAndMatchingFolders = new ObservableCollection<Tuple<string, string,string>>();
            foreach (string key in possibleMatchesOfOldToNewFolders.Keys)
            {
                missingAndMatchingFolders.Add(new Tuple<string,string, string>(Path.GetFileName(key), key, possibleMatchesOfOldToNewFolders[key]));
            }
            this.MatchDataGrid.ItemsSource = missingAndMatchingFolders;
        }

        // Label and size the datagrid column headers
        private void MatchDataGrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.MatchDataGrid.Columns[0].Header = "Folder name";
            this.MatchDataGrid.Columns[0].Width = new DataGridLength(1, DataGridLengthUnitType.Auto);
            this.MatchDataGrid.Columns[1].Header = "Expected old  location";
            this.MatchDataGrid.Columns[1].Width = new DataGridLength(2, DataGridLengthUnitType.Star);
            this.MatchDataGrid.Columns[2].Header = "Possible new location";
            this.MatchDataGrid.Columns[2].Width = new DataGridLength(2, DataGridLengthUnitType.Star);
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }

        private void ManuallyLocateFolders_Click(object sender, RoutedEventArgs e)
        {
            // Null signals a request to manually locate folders
            this.DialogResult = false;
            this.IsCancelled = false; // false/false is a manually locate request
            return;
        }

        private void Ok_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = true;
            this.IsCancelled = false;
        }

        private void MatchDataGrid_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            try
            { 
                Tuple<string, string, string> rowValues = (Tuple<string,string,string>) MatchDataGrid.SelectedItem;
                string relativePath = (string)rowValues?.Item3;
                if (String.IsNullOrWhiteSpace(relativePath))
                {
                    return;
                }
                ProcessStartInfo startInfo = new ProcessStartInfo
                {
                    Arguments = Path.Combine(this.RootPath, relativePath),
                    FileName = "explorer.exe"
                };
                Util.ProcessExecution.TryProcessStart(startInfo);
            }
            catch { }
        }
    }
}
