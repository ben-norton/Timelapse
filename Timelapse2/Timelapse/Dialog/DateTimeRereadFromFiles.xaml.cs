using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using Timelapse.Database;
using Timelapse.Enums;
using Timelapse.Util;

namespace Timelapse.Dialog
{
    public partial class DateTimeRereadFromFiles : Window
    {
        private readonly FileDatabase database;

        public DateTimeRereadFromFiles(FileDatabase database, Window owner)
        {
            this.InitializeComponent();
            this.database = database;
            this.Owner = owner;
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            Dialogs.TryPositionAndFitDialogIntoWindow(this);
        }

        // Label and size the datagrid column headers
        private void DatagridFeedback_AutoGeneratedColumns(object sender, EventArgs e)
        {
            this.FeedbackGrid.Columns[0].Header = "File name (only for files whose date differs)";
            this.FeedbackGrid.Columns[0].Width = new DataGridLength(1, DataGridLengthUnitType.Auto);
            this.FeedbackGrid.Columns[1].Header = "Old date  \x2192  New Date if it differs";
            this.FeedbackGrid.Columns[1].Width = new DataGridLength(2, DataGridLengthUnitType.Star);

        }

        private void StartDoneButton_Click(object sender, RoutedEventArgs e)
        {
            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<DateTimeRereadFeedbackTuple> feedbackRows = new ObservableCollection<DateTimeRereadFeedbackTuple>();
            //this.FeedbackGrid.ItemsSource = feedbackRows;
            this.cancelButton.IsEnabled = false;
            this.StartDoneButton.Content = "_Done";
            this.StartDoneButton.Click -= this.StartDoneButton_Click;
            this.StartDoneButton.Click += this.DoneButton_Click;
            this.StartDoneButton.IsEnabled = false;

#pragma warning disable CA2000 // Dispose objects before losing scope. Reason: Not required as Dispose on BackgroundWorker doesn't do anything
            BackgroundWorker backgroundWorker = new BackgroundWorker()
            {
                WorkerReportsProgress = true
            };
#pragma warning restore CA2000 // Dispose objects before losing scope

            backgroundWorker.DoWork += (ow, ea) =>
            {
                // this runs on the background thread; its written as an anonymous delegate
                // We need to invoke this to allow updates on the UI
                this.Dispatcher.Invoke(new Action(() =>
                {
                    // First, provide initial feedback
                    backgroundWorker.ReportProgress(0, "Pass 1: Examining image and video dates...");
                }));

                // Pass 1. Check to see what dates/times need updating.
                List<ImageRow> filesToAdjust = new List<ImageRow>();
                int count = this.database.CurrentlySelectedFileCount;
                TimeZoneInfo imageSetTimeZone = this.database.ImageSet.GetSystemTimeZone();
                for (int fileIndex = 0; fileIndex < count; ++fileIndex)
                {
                    // We will store the various times here
                    ImageRow file = this.database.FileTable[fileIndex];
                    DateTimeOffset originalDateTime = file.DateTimeIncorporatingOffset;
                    string feedbackMessage = String.Empty;
                    try
                    {
                        // Get the image (if its there), get the new dates/times, and add it to the list of images to be updated 
                        // Note that if the image can't be created, we will just to the catch.
                        bool usingMetadataTimestamp = true;
                        if (file.FileExists(this.database.FolderPath) == false)
                        {
                            // The file does not exist. Generate a feedback message
                            feedbackMessage = "\x2716 Missing file - date unchanged."; // X mark
                            feedbackRows.Add(new DateTimeRereadFeedbackTuple(file.File, feedbackMessage));
                        }
                        else
                        {
                            // Read the date from the file, and check to see if its different from the recorded date
                            DateTimeAdjustmentEnum dateTimeAdjustment = file.TryReadDateTimeOriginalFromMetadata(this.database.FolderPath, imageSetTimeZone);
                            if (dateTimeAdjustment == DateTimeAdjustmentEnum.MetadataNotUsed)
                            {
                                // We couldn't read the metadata, so get a candidate date/time from the file info instead
                                file.SetDateTimeOffsetFromFileInfo(this.database.FolderPath);  
                                usingMetadataTimestamp = false;
                            }
                            DateTimeOffset rescannedDateTime = file.DateTimeIncorporatingOffset;
                            bool sameDate = (rescannedDateTime.Date == originalDateTime.Date) ? true : false;
                            bool sameTime = (rescannedDateTime.TimeOfDay == originalDateTime.TimeOfDay) ? true : false;
                            bool sameUTCOffset = (rescannedDateTime.Offset == originalDateTime.Offset) ? true : false;

                            if  (!(sameDate && sameTime && sameUTCOffset))
                            {
                                // Date has been updated - add it to the queue of files to be processed, and generate a feedback message.
                                filesToAdjust.Add(file);
                                feedbackMessage = "\x2713"; // Checkmark 
                                feedbackMessage += DateTimeHandler.ToDisplayDateTimeString(originalDateTime) + " \x2192 " + DateTimeHandler.ToDisplayDateTimeString(rescannedDateTime);
                                feedbackMessage += usingMetadataTimestamp ? " (read from metadata)" : " (read from file)";
                                feedbackRows.Add(new DateTimeRereadFeedbackTuple(file.File, feedbackMessage));
                            }
                        }
                    }
                    catch (Exception exception)
                    {
                        // This shouldn't happen, but just in case.
                        TraceDebug.PrintMessage(String.Format("Unexpected exception processing '{0}' in DateTimeReread. {1}", file.File, exception.ToString()));
                        feedbackMessage += String.Format("\x2716 skipping: {0}", exception.Message);
                        feedbackRows.Add(new DateTimeRereadFeedbackTuple(file.File, feedbackMessage));
                    }
                    backgroundWorker.ReportProgress(Convert.ToInt32(fileIndex / Convert.ToDouble(count) * 100.0), String.Format ("Pass 1: Checking dates for {0} / {1} files", fileIndex, count));

                    if (fileIndex % Constant.ThrottleValues.SleepForImageRenderInterval == 0)
                    {
                        // Put in a delay every now and then, as otherwise the UI won't update.
                        Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime); 
                    }
                }

                // Pass 2. Update each date as needed 
                if (filesToAdjust.Count <= 0 )
                {
                    // If none of the file dates need updating, just say so and bail out of here.
                    feedbackRows.Insert(0, new DateTimeRereadFeedbackTuple("---", "No files updated as their dates have not changed."));
                    return;
                }

                // We have files whose dates have to be updated in the database 
                // Provide feedback on the second pass
                backgroundWorker.ReportProgress(0, String.Format("Pass 2: Updating {0} files. Please wait...", filesToAdjust.Count));
                Thread.Sleep(Constant.ThrottleValues.RenderingBackoffTime);  // Allow the UI to update.
                
                // Update the database
                List<ColumnTuplesWithWhere> imagesToUpdate = new List<ColumnTuplesWithWhere>();
                foreach (ImageRow image in filesToAdjust)
                {
                    imagesToUpdate.Add(image.GetDateTimeColumnTuples());
                }
                this.database.UpdateFiles(imagesToUpdate);  // Write the updates to the database

                // Provide summary feedback
                feedbackRows.Insert(0, (new DateTimeRereadFeedbackTuple("---", String.Format("Updated {0}/{1} files whose dates have changed", filesToAdjust.Count, count))));
            };

            backgroundWorker.ProgressChanged += (o, ea) =>
            {
                // Update the progress bar
                this.UpdateProgress(ea.ProgressPercentage, (string)ea.UserState);     
            };

            backgroundWorker.RunWorkerCompleted += (o, ea) =>
            {
                // Hide the busy indicator and display information about each changed file
                this.BusyIndicator.IsBusy = false;
                this.FeedbackGrid.Visibility = Visibility.Visible;
                this.FeedbackGrid.ItemsSource = feedbackRows;
                this.StartDoneButton.IsEnabled = true;
            };

            // Show the busy indicator
            this.BusyIndicator.IsBusy = true;
            backgroundWorker.RunWorkerAsync();
        }

        // Convenience routing to show progress information in the progress bar
        private void UpdateProgress(int percent, string message)
        {
            ProgressBar bar = Utilities.GetVisualChild<ProgressBar>(this.BusyIndicator);
            TextBlock textmessage = Utilities.GetVisualChild<TextBlock>(this.BusyIndicator);
            if (bar != null)
            {
                bar.Value = percent;
            }
            if (textmessage != null)
            {
                textmessage.Text = message;
            }
        }
         
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }

        private void DoneButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = true;
        }
    }
}
